import { Box2, BufferGeometry, Camera, DataTexture, Object3D, Texture, TextureEncoding, Vector4, WebGLRenderer, WebGLRenderTarget } from 'three';
import { ITexture } from 'webgi/interfaces';
import { Color } from 'three/src/math/Color';
export declare function computeScreenSpaceBoundingBox(obj: Object3D, camera: Camera): Box2;
export declare const RGBM16Encoding_: TextureEncoding;
export declare function getEncodingComponents(encoding: TextureEncoding): string[];
export declare function getTextureEncodingFromMap(map: Texture | WebGLRenderTarget | null | undefined | any, isWebGL2: boolean): TextureEncoding;
export declare function getTexelDecodingFunction(functionName: string, encoding: TextureEncoding): string;
export declare function getTexelDecoding(mapName: string, map: ITexture | undefined, isWebGL2: boolean): string;
export declare function getTexelDecoding2(mapName: string, encoding: TextureEncoding): string;
export declare function getTexelEncodingFunction(functionName: string, encoding: TextureEncoding): string;
export declare function getTexelEncoding(functionName: string, map: ITexture, isWebGL2: boolean): string;
/**
 *
 * @param uniforms - object for setting uniform value (like ShaderMaterial.uniforms
 * @param propKey - uniform name
 * @param thisTarget - if `this` is the uniform (because uniforms = this wont work). It also adds _ in front of the name
 */
export declare function uniform({ uniforms, propKey, thisTarget }?: {
    uniforms?: any;
    propKey?: string | symbol;
    thisTarget?: boolean;
}): PropertyDecorator;
/**
 *
 * @param customDefines - object for setting define value (like ShaderMaterial.defines), otherwise this.material.defines is taken
 * @param key - define name
 * @param thisMat - access this.defines instead of this.material.defines
 */
export declare function matDefine(key?: string | symbol, customDefines?: any, thisMat?: boolean, onChange?: (...args: any[]) => any): PropertyDecorator;
export declare function dataTextureFromColor(color: Color): DataTexture;
export declare function dataTextureFromVec4(color: Vector4): DataTexture;
export declare function setThreeRendererMode(renderer: WebGLRenderer, ud: {
    shadowMapRender?: boolean;
    backgroundRender?: boolean;
    sceneRender?: boolean;
    opaqueRender?: boolean;
    transparentRender?: boolean;
    transmissionRender?: boolean;
    mainRenderPass?: boolean;
    screenSpaceRendering?: boolean;
}, render: () => void): void;
export declare function autoCenterObject3D(obj: Object3D): void;
export declare function autoScaleObject3D(obj: Object3D, autoScaleRadius?: number): Object3D<import("three").Event>;
/**
 * Convert geometry to BufferGeometry with indexed attributes.
 */
export declare function toIndexedGeometry(geometry: BufferGeometry, tolerance?: number): BufferGeometry;
//# sourceMappingURL=threeUtils.d.ts.map