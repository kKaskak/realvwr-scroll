import { IFilter, IRenderTarget, IViewerPlugin, UiObjectConfig } from 'webgi/interfaces';
import { AddBlendPass } from 'webgi/passes/threejs/AddBlendPass';
import { IUniform, OrthographicCamera, PerspectiveCamera } from 'three';
import { MultiFilterPlugin } from 'webgi/plugins/MultiFilterPlugin';
import { ViewerApp } from 'webgi/viewer/ViewerApp';
export declare class ProgressivePlugin extends MultiFilterPlugin<'', [IFilter<AddBlendPass, 'progressive'>], ViewerApp> implements IViewerPlugin {
    static readonly PluginType = "Progressive";
    private _lastFrame?;
    enabled: boolean;
    maxFrameCount: number;
    jitter: boolean;
    private _hasSetOffset;
    trackedJitterCameras: Set<[PerspectiveCamera | OrthographicCamera, {
        width: number;
        height: number;
    }]>;
    constructor(maxFrameCount?: number);
    onAdded(viewer: ViewerApp): Promise<void>;
    onRemove(viewer: ViewerApp): Promise<void>;
    get lastFrame(): IRenderTarget | undefined;
    createPasses(viewer: ViewerApp): [IFilter<AddBlendPass, 'progressive'>];
    private _addSceneObject;
    private _jitterCamera;
    private _resetCameraJitter;
    /**
     *
     * @param postRender - if called after rendering frame.
     */
    isConverged(postRender?: boolean): boolean;
    updateShaderProperties(material: {
        defines: Record<string, string | number | undefined>;
        uniforms: {
            [p: string]: IUniform;
        };
    }): this;
    uiConfig: UiObjectConfig;
    /**
     * Get recording delta post render, For use with animations to sync with converge mode in canvas recorder. See PopmotionPlugin for usage.
     * @returns {number} - delta time in milliseconds, or 0 when converging, or -1 in case of not recording in converge mode
     */
    postFrameConvergedRecordingDelta(recorderPlugin?: string): number;
}
export interface IConvergedCanvasRecorder {
    convergeMode: boolean;
    isRecording(): boolean;
    videoFrameRate: number;
}
//# sourceMappingURL=ProgressivePlugin.d.ts.map