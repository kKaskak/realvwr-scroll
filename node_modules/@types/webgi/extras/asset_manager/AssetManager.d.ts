import { IEventDispatcher } from '../../helpers/EventDispatcher';
import { AnyOptions, IDisposable, IFile, ISceneObject, TAssetTypes } from 'webgi/interfaces';
import { SimpleAssetList } from 'webgi/extras/asset_manager/importer/SimpleAssetList';
import { ObjectProcessorMap } from 'webgi/helpers/ObjectProcessorMap';
import { BlobExt } from 'webgi/extras/asset_manager/exporter/threejs/AssetExporter';
import { Object3DModelOptions } from 'webgi/core/threejs/Object3DModel';
import { GLTFExporter2Options } from 'webgi/extras/asset_manager/exporter/threejs/exporters/GLTFExporter2';
export interface ILoader {
    loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<any>;
}
export interface IExportParser {
    parseAsync(obj: any, options: AnyOptions): Promise<Blob>;
}
export interface IImporter {
    ext: string[];
    root: boolean;
    ctor: (assetImporter: IAssetImporter) => ILoader | undefined;
}
export interface IExporter {
    extensions?: any[];
    ext: string[];
    ctor: (assetImporter: IAssetExporter) => IExportParser | undefined;
}
export declare type IAssetID = string;
export interface IAssetSearchQuery {
    query: RegExp;
}
export interface IAsset {
    id?: IAssetID;
    path: string;
    file?: IFile;
    variants?: IAssetID[];
    preImported?: Promise<ISceneObject[]>;
    [id: string]: any;
}
export interface IAssetList {
    basePath?: string;
    assets: IAsset[];
}
export interface IDataSource extends IEventDispatcher<string> {
    addAssetList(list: SimpleAssetList): void;
    removeAssetList(list: SimpleAssetList): void;
    findAssetRegex(query: RegExp): Promise<IAsset | undefined>;
    findAsset(query: IAssetSearchQuery): Promise<IAsset | undefined>;
    findAssetSimple(match: string, ignoreCase?: boolean): Promise<IAsset | undefined>;
}
export declare type ExportFileOptions = {
    exportExt?: string;
    viewerConfig?: boolean;
} & GLTFExporter2Options & AnyOptions;
export interface IAssetExporter extends IEventDispatcher<'exportFile' | 'exporterCreate'> {
    getExporter(...ext: string[]): IExporter | undefined;
    exportObject(obj?: ISceneObject, options?: ExportFileOptions): Promise<BlobExt | undefined>;
    processors: ObjectProcessorMap<TAssetTypes>;
}
export interface IAssetManager extends IEventDispatcher<string> {
    importer?: IAssetImporter;
    exporter?: IAssetExporter;
}
export declare type ProcessImportedOptions = {
    processImported?: boolean;
    forceImporterReprocess?: boolean;
    rootPath?: string;
    generateMipmaps?: boolean | undefined;
    _testDataTextureComplete?: boolean;
} & Object3DModelOptions & AnyOptions;
export interface ImportFileOptions {
    fileHandler?: any;
    queryString?: string;
    rootPath?: string;
}
export declare type ImportFilesOptions = ProcessImportedOptions & ImportFileOptions & {
    allowedExtensions?: string[];
};
export declare type ImportAssetOptions = {
    /**
     * Default = false. If true, the asset will be imported again on subsequent calls.
     */
    forceImport?: boolean;
    /**
     * If true or not specified, and any of the assets is disposed(only root objects are checked, not children), all assets will be imported in this call. If false, old assets will be returned.
     * Default = true.
     */
    reimportDisposed?: boolean;
    pathOverride?: string;
} & ProcessImportedOptions & ImportFileOptions & AnyOptions;
export interface IAssetImporter extends IEventDispatcher<'onLoad' | 'onProgress' | 'onStop' | 'onError' | 'onStart' | 'loaderCreate' | string>, IDisposable {
    loadingManager: any;
    registerFile(path: string, file?: IFile): ILoader | undefined;
    unregisterFile(path: string): void;
    processors: ObjectProcessorMap<TAssetTypes>;
    processImported(res: any, options: ProcessImportedOptions): Promise<ISceneObject[]>;
    /**
     * Returns the object or undefined
     * @param asset
     * @param options
     */
    importAsset(asset?: IAsset, options?: ImportAssetOptions): Promise<ISceneObject[]>;
    importSingle<T>(asset?: IAsset, options?: ImportAssetOptions): Promise<T | undefined>;
    importFiles(files: Map<string, IFile>, onProgress?: (event: ProgressEvent) => void, options?: ImportFilesOptions): Promise<Map<string, ISceneObject[]> | undefined>;
    importPath(path: string, options: ImportAssetOptions): Promise<ISceneObject[]>;
}
//# sourceMappingURL=AssetManager.d.ts.map