import { IUniform, Object3D, Shader, WebGLRenderer } from 'three';
import { IMaterial, IShaderPropertiesUpdater, UiObjectConfig } from 'webgi/interfaces';
export interface MaterialExtension {
    parsFragmentSnippet?: string | ((renderer?: WebGLRenderer, material?: IMaterial) => string);
    parsVertexSnippet?: string | ((renderer?: WebGLRenderer, material?: IMaterial) => string);
    extraUniforms?: {
        [uniform: string]: IUniform;
    };
    shaderExtender?: (shader: Shader, material: IMaterial, renderer: WebGLRenderer) => void;
    customCacheKey?: string;
    computeCacheKey?: (material: IMaterial) => string;
    onObjectRender?: (object: Object3D, material: IMaterial, renderer: WebGLRenderer) => void;
    onAfterRender?: (object: Object3D, material: IMaterial, renderer: WebGLRenderer) => void;
    isCompatible: (material: IMaterial) => boolean;
    updaters?: IShaderPropertiesUpdater[] | (() => IShaderPropertiesUpdater[]);
    getUiConfig?: (material: IMaterial) => UiObjectConfig | undefined;
    updateVersion?: number;
    __setDirty?: () => void;
    uuid?: string;
    setDirty?: () => void;
}
export declare class MaterialExtender {
    static FragVoidMain: string;
    static VertVoidMain: string;
    static ApplyMaterialExtensions(material: IMaterial, shader: Shader, materialExtensions: MaterialExtension[], renderer: WebGLRenderer): void;
    static ApplyMaterialExtension(material: IMaterial, shader: Shader, materialExtension: MaterialExtension, renderer: WebGLRenderer): void;
    static CacheKeyForExtensions(material: IMaterial, materialExtensions: MaterialExtension[]): string;
    static CacheKeyForExtension(material: IMaterial, materialExtension: MaterialExtension): string;
    static RegisterExtensions(material: IMaterial, customMaterialExtensions?: MaterialExtension[]): MaterialExtension[];
}
//# sourceMappingURL=MaterialExtender.d.ts.map