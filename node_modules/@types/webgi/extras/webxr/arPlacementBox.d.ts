import { BufferGeometry, Camera, Mesh, MeshBasicMaterial, Object3D, Vector3 } from 'three';
import { Box3B } from 'webgi/helpers/threejs/Box3B';
/**
 * This class is a set of two coincident planes. The first is just a cute box
 * outline with rounded corners and damped opacity to indicate the floor extents
 * of a scene. It is purposely larger than the scene's bounding box by RADIUS on
 * all sides so that small scenes are still visible / selectable. Its center is
 * actually carved out by vertices to ensure its fragment shader doesn't add
 * much time.
 *
 * The child plane is a simple plane with the same extents for use in hit
 * testing (translation is triggered when the touch hits the plane, rotation
 * otherwise).
 */
export declare class ARPlacementBox extends Mesh<BufferGeometry, MeshBasicMaterial> {
    hitPlane: Mesh<BufferGeometry, MeshBasicMaterial>;
    shadowHeight: number;
    readonly boundingSize: Vector3;
    private _placeOnWall;
    private _camera;
    constructor(boundingBox: Box3B, camera: Camera, placeOnWall?: boolean);
    /**
     * Get the world hit position if the touch coordinates hit the box, and null
     * otherwise. Pass the scene in to get access to its raycaster.
     */
    getHit(scene: Object3D, screenX: number, screenY: number): Vector3 | null;
    getExpandedHit(scene: Object3D, screenX: number, screenY: number): Vector3 | null;
    /**
     * Offset the height of the box relative to the bottom of the scene. Positive
     * is up, so generally only negative values are used.
     */
    set offsetHeight(offset: number);
    get offsetHeight(): number;
    /**
     * Set the box's visibility; it will fade in and out.
     */
    set show(visible: boolean);
    get show(): boolean;
    /**
     * Call on each frame with the frame delta to fade the box.
     */
    updateOpacity(delta: number): void;
    /**
     * Call this to clean up Three's cache when you remove the box.
     */
    dispose(): void;
    private _raycaster;
    /**
     * This method returns the world position, model-space normal and texture
     * coordinate of the point on the mesh corresponding to the input pixel
     * coordinates given relative to the model-viewer element. If the mesh
     * is not hit, the result is null.
     */
    private _positionAndNormalFromPoint;
}
//# sourceMappingURL=arPlacementBox.d.ts.map