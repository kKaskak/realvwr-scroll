import type { Box3B } from './helpers/threejs/Box3B';
import { IEvent, IEventDispatcher } from 'webgi/helpers/EventDispatcher';
import type { IUniform, TextureDataType, TextureEncoding, TextureFilter, Vector3Tuple, Vector4Tuple, WebGLRenderTargetOptions } from 'three';
import { MaterialExtension } from 'webgi/extras/asset_manager/threejs/MaterialExtender';
export declare type Class<T> = new (...args: any[]) => T;
export declare type PartialRecord<K extends keyof any, T> = {
    [P in K]?: T;
};
export declare type PartialPick<T, K extends keyof T> = Partial<T> & Pick<T, K>;
declare type StringKeyOf<T extends any> = Extract<keyof T, string>;
export declare type AnyOptions = Record<string, any>;
export declare type TAssetTypes = 'model' | 'texture' | 'light' | 'material';
export declare type IFile = Partial<File> & {
    name: string;
    type: string;
    objectUrl?: string;
    importId?: string;
    ext?: string;
};
export interface IDisposable {
    dispose(): void;
}
/**
 * Scene
 */
export interface AddModelOptions {
    autoScale?: boolean;
    autoScaleRadius?: number;
}
export declare type ISceneObject<T = any> = (IModel<T> | ILight<T> | ITexture<T> | IMaterial<T>) & IUiConfigContainer;
export interface IWidget<T = any> extends Omit<IModel<T>, 'assetType'> {
    attach(object: any): this;
    detach(): this;
    assetType: 'widget';
    modelObject: any;
}
export declare type TSceneEvents = 'sceneUpdate' | 'addSceneObject' | 'update' | 'textureAdded' | 'activeCameraChange' | 'activeCameraUpdate' | 'sceneMaterialUpdate' | 'environmentChanged' | 'select' | 'objectUpdate' | 'materialUpdate' | 'setView' | 'activateMain';
export interface IScene<TScene = any, TCamera extends ICamera<ICameraOptions> = ICamera<ICameraOptions>> extends IEventDispatcher<TSceneEvents>, IDisposable, IUiConfigContainer, IShaderPropertiesUpdater {
    name: string;
    readonly uuid: string;
    readonly visible: boolean;
    assetType: 'model';
    modelObject: TScene;
    activeCamera: TCamera;
    modelRoot: IModel;
    addModel(model: IModel, options?: AddModelOptions): void;
    addLight(light: ILight, options?: AnyOptions): void;
    addSceneObject<T extends ISceneObject>(imported: T, options?: AnyOptions): T;
    setDirty(options?: AnyOptions): this;
    getBounds(precise?: boolean, ignoreInvisible?: boolean): Box3B;
    findObjectsByName(name: string, parent?: any): any[];
    setEnvironment(asset: ITexture | null | undefined): void;
    getEnvironment(): ITexture;
    setBackground(asset: ITexture | string | number | null | any): void;
    getBackground(): ITexture | null | any;
    envMapIntensity: number;
    addWidget(widget: IWidget, options?: AnyOptions): void;
    defaultCamera: TCamera;
    userData: any;
}
/**
 * Renderer
 */
export interface IRenderOptions {
    clear?: boolean;
    material?: IMaterial;
    shader?: IShader;
    pass?: IFilter<IPass, IPassID>;
    viewport?: Vector4Tuple;
}
export interface IShaderPropertiesUpdater {
    updateShaderProperties(material: {
        defines: Record<string, string | number | undefined>;
        uniforms: {
            [name: string]: IUniform;
        };
    }): this;
}
export interface CreateRenderTargetOptions {
    sizeMultiplier?: number;
    size?: {
        width: number;
        height: number;
    };
    generateMipmaps?: boolean;
    samples?: number;
    minFilter?: TextureFilter;
    magFilter?: TextureFilter;
    encoding?: TextureEncoding;
    type?: TextureDataType;
    format?: number;
    depthBuffer?: boolean;
    depthTexture?: boolean;
    textureCount?: number;
}
export interface IEffectComposer {
    renderToScreen: boolean;
}
export interface IRenderer extends IEventDispatcher<'animationLoop' | 'update' | 'resize' | string>, IShaderPropertiesUpdater {
    passes: IFilter<IPass, IPassID>[];
    dirty: boolean;
    composer: IEffectComposer;
    isWebGL2: boolean;
    frameCount: number;
    displayCanvasScaling: number;
    clearColor({ r, g, b, a, target, depth, stencil, }: {
        r?: number;
        g?: number;
        b?: number;
        a?: number;
        target?: IRenderTarget;
        depth?: boolean;
        stencil?: boolean;
    }): void;
    blit(source: ITexture | undefined, destination: IRenderTarget | undefined, options?: IRenderOptions): void;
    renderScene(scene: IScene): void;
    renderModel(model: IModel, camera: ICamera<ICameraOptions>): void;
    context: WebGLRenderingContext;
    rendererObject: any;
    pipeline: IPassID[];
    composerTarget: IRenderTarget;
    refreshPipeline(): IPassID[];
    reset(): void;
    resetShadows(): void;
    registerPass(pass: IFilter<IPass, IPassID>, replaceId?: boolean): void;
    unregisterPass(pass: IFilter<IPass, IPassID>): void;
    createTarget(options?: CreateRenderTargetOptions): IRenderTarget;
    createTargetCustom<T extends IRenderTarget>({ width, height }: {
        width: number;
        height: number;
    }, options?: WebGLRenderTargetOptions, clazz?: Class<T>): T;
    disposeTarget(target: IRenderTarget): void;
    trackTarget(target: IRenderTarget): void;
    removeTrackedTarget(target: IRenderTarget): void;
    getTempTarget(op?: CreateRenderTargetOptions): IRenderTarget;
    releaseTempTarget(target: IRenderTarget): void;
}
/**
 * Camera
 */
export interface ICameraOptions {
    /**
     * @default 1
     */
    zoom: number;
    /**
     * Camera frustum aspect ratio, window width divided by window height.
     * @default 1
     */
    aspect: number | 'auto';
    controlsMode: TCameraControlsMode;
    controlsEnabled: boolean;
    position: Vector3Tuple;
    target: Vector3Tuple;
}
export declare type TCameraControlsMode = '' | 'orbit' | 'deviceOrientation' | 'firstPerson' | 'pointerLock' | string;
export interface IPerspectiveCameraOptions extends ICameraOptions {
    type: 'PerspectiveCamera';
    /**
     * Camera frustum vertical field of view, from bottom to top of view, in degrees.
     * @default 50
     */
    fov: number;
    /**
     * @default 10
     */
    focus: number;
}
export interface IOrthographicCameraOptions extends ICameraOptions {
    type: 'OrthographicCamera';
    /**
     * Camera frustum size.
     * top, bottom, left, right are ignored if this is not undefined
     * @default 1
     */
    frustumSize?: number;
    /**
     * Camera frustum left plane.
     * @default -1
     */
    left: number;
    /**
     * Camera frustum right plane.
     * @default 1
     */
    right: number;
    /**
     * Camera frustum top plane.
     * @default 1
     */
    top: number;
    /**
     * Camera frustum bottom plane.
     * @default -1
     */
    bottom: number;
}
export interface ICamera<TOptions extends ICameraOptions = ICameraOptions, TCamera = any, TControls = any> extends IModel, IShaderPropertiesUpdater, IJSONSerializable {
    near: number;
    far: number;
    setDirty(options?: AnyOptions): void;
    isActiveCamera: boolean;
    activateMain(): void;
    deactivateMain(): void;
    cameraObject: TCamera;
    controls: TControls | undefined;
    positionUpdated(): void;
    targetUpdated(): void;
    refreshTarget(): void;
    target: any;
    position: any;
    interactionsEnabled: boolean;
    getCameraOptions(): TOptions;
    setCameraOptions(value: Partial<TOptions>, setDirty?: boolean): void;
}
/**
 * Others
 */
export declare type IGeometry = any;
export interface IModel<TModel = any> extends IEventDispatcher<'objectUpdate' | 'materialUpdate' | 'materialChanged' | 'select' | 'added' | 'removed' | 'dispose' | 'geometryUpdate' | string>, Partial<IDisposable>, IUiConfigContainer {
    name: string;
    readonly uuid: string;
    visible: boolean;
    assetType: 'model';
    /**
     * Internal three.js Object3D instance (like Mesh, Group, etc)
     */
    modelObject: TModel;
    /**
     * Use `setMaterial` to change the material
     * Get one or more materials applied to an object
     */
    readonly material?: IMaterial | IMaterial[] | undefined;
    readonly geometry?: IGeometry | undefined;
    setMaterial?: (material: IMaterial | IMaterial[] | undefined) => IMaterial[];
    /**
     * returns the old geometry.
     * @param geometry
     * @param force
     */
    setGeometry?: (geometry: IGeometry | undefined, force?: boolean) => IGeometry | undefined;
    setDirty?: (options?: AnyOptions) => void;
    userData: any;
}
export interface ILight<TLight = any> extends Omit<IModel<TLight>, 'assetType'>, IUiConfigContainer, IJSONSerializable {
    assetType: 'light';
    lightObject: TLight;
}
export interface IMaterial<TMaterial = any> extends IEventDispatcher<string>, IUiConfigContainer, IJSONSerializable, IDisposable {
    assetType: 'material';
    name: string;
    uuid: string;
    materialObject: TMaterial;
    userData: any;
    readonly typeSlug: string;
    extraUniformsToUpload?: Record<string, IUniform>;
    materialExtensions?: MaterialExtension[];
    registerMaterialExtensions?: (customMaterialExtensions: MaterialExtension[]) => void;
    unregisterMaterialExtensions?: (customMaterialExtensions: MaterialExtension[]) => void;
    copyProps(oldMaterial: any): this;
    clone?: () => any;
    needsUpdate: boolean;
    setDirty(options?: AnyOptions): void;
}
export declare type IShader = IEventDispatcher<string>;
export declare type IPassID = string;
export interface IPass extends IUiConfigContainer, Partial<IDisposable> {
    enabled: boolean;
    needsSwap: boolean;
    clear: boolean;
    renderToScreen: boolean;
    uniforms?: {
        [name: string]: IUniform;
    };
    setSize(width: number, height: number): void;
    render(renderer: any, writeBuffer: any, readBuffer: any, deltaTime: number, maskActive: boolean): void;
    onDirty?: (() => void)[];
    updateShaderProperties?: (updater?: (IShaderPropertiesUpdater | undefined) | (IShaderPropertiesUpdater | undefined)[]) => void;
    materialExtension?: MaterialExtension;
}
export interface IFilter<T extends IPass, Tid extends IPassID> extends Partial<IDisposable> {
    enabled?: boolean;
    dirty?: boolean;
    passId: Tid;
    passObject: T;
    update?(): void;
    onRegister?(renderer: IRenderer): void;
    onUnregister?(renderer: IRenderer): void;
    after?: IPassID[];
    before?: IPassID[];
    required?: IPassID[];
}
export interface ITexture<TTexture = any> extends IEventDispatcher<string>, IDisposable {
    assetType?: 'texture';
    minFilter: any;
    magFilter: any;
    generateMipmaps: boolean;
    encoding: any;
    name: string;
    source: any;
    textureObject?: TTexture;
    mapping: number;
    needsUpdate?: boolean;
    rotation: number;
    image?: {
        width: number;
        height: number;
    };
    isDataTexture?: boolean;
    isRenderTargetTexture?: boolean;
    toJSON(meta?: any): any;
    userData: any;
}
export interface IRenderTarget extends IEventDispatcher<string>, IDisposable {
    texture: ITexture;
    sizeMultiplier?: number;
    isTemporary?: boolean;
    targetKey?: string;
    samples?: number;
    clone(trackTarget?: boolean): IRenderTarget;
}
/**
 * Viewer
 */
export declare enum ViewerState {
    Error = -2,
    Destroyed = -1,
    None = 0,
    Running = 1,
    Paused = 2
}
export interface IJSONSerializable {
    toJSON(meta?: any): any;
    fromJSON(data: any, meta?: any): this | null | Promise<this | null>;
}
export interface IViewerApp extends IEventDispatcher<'update' | 'preRender' | 'postRender' | 'preFrame' | 'postFrame' | 'dispose' | 'addPlugin'>, IJSONSerializable {
    state: ViewerState;
    renderer: IRenderer;
    scene: IScene;
    readonly plugins: Record<string, IViewerPlugin>;
    container: HTMLElement;
    canvas: HTMLCanvasElement;
    useRgbm: boolean;
    useGBufferDepth: boolean;
    isAntialiased: boolean;
    addPlugin<T extends IViewerPlugin>(plugin: T): Promise<T>;
    addPlugin<T extends IViewerPlugin>(plugin: Class<T>, ...args: ConstructorParameters<Class<T>>): Promise<T>;
    removePlugin(plugin: IViewerPlugin): Promise<void>;
    getPlugin<T extends IViewerPlugin>(type: Class<T>): T | undefined;
    getPluginByType<T extends IViewerPlugin>(type: string): T | undefined;
    setDirty(): void;
    createCamera(cameraObject: any): ICamera<ICameraOptions>;
    setBackgroundColor(color: string | number | any): void;
    setBackground(asset: ITexture | string | number | null): void;
    getBackground(raw?: boolean): ITexture | string | number | null;
    resetCamera(options?: AnyOptions): void;
    alert: (message?: string) => Promise<void>;
    confirm: (message?: string) => Promise<boolean>;
    prompt: (message?: string, _default?: string, cancel?: boolean) => Promise<string | null>;
}
export interface IViewerPlugin<TViewer extends IViewerApp = IViewerApp> extends IEventDispatcher<string>, IUiConfigContainer, Partial<IJSONSerializable> {
    dependencies?: Class<IViewerPlugin<any>>[];
    dirty?: boolean;
    onAdded(viewer: TViewer): Promise<void>;
    onRemove(viewer: TViewer): Promise<void>;
    onDispose(viewer: TViewer): Promise<void>;
    serializeWithViewer?: boolean | undefined;
}
/**
 * UI
 */
export declare type TUiRefreshModes = 'preRender' | 'postRender' | 'preFrame' | 'postFrame';
export declare type UiObjectType = string;
export interface UiObjectConfig<T = any, TType extends UiObjectType = UiObjectType> {
    uuid?: string;
    type?: TType;
    label?: string | (() => string);
    children?: (UiObjectConfig | (() => UiObjectConfig | UiObjectConfig[]))[];
    property?: [T, StringKeyOf<T>];
    value?: T;
    getValue?: () => T;
    setValue?: (value: T) => void;
    hidden?: boolean | (() => boolean);
    expanded?: boolean | (() => boolean);
    inlinePicker?: boolean | (() => boolean);
    disabled?: boolean | (() => boolean);
    uiRef?: any;
    uiRefType?: UiObjectType;
    uiRefresh?: (mode?: TUiRefreshModes | 'immediate', deep?: boolean, delay?: number) => void;
    onChange?: ((...args: any[]) => void) | (undefined | ((...args: any[]) => void))[];
    bounds?: number[] | (() => number[]);
    stepSize?: number;
    isMonitor?: boolean;
    limitedUi?: boolean;
    onExpand?: (c: UiObjectConfig) => void;
    [id: string]: any;
    domChildren?: HTMLElement[] | (() => HTMLElement[]);
    alert?: Parameters<IViewerApp['alert']>;
    confirm?: Parameters<IViewerApp['confirm']>;
    prompt?: Parameters<IViewerApp['prompt']>;
}
export interface IUiConfigContainer<TValue = any, TType extends string = string> {
    uiConfig?: UiObjectConfig<TValue, TType>;
}
export interface IGBufferUpdater {
    updateGBuffer: (model: any, data: any) => void;
}
export { IEvent, IEventDispatcher };
//# sourceMappingURL=interfaces.d.ts.map