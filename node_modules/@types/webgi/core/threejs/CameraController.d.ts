import { Camera, IUniform, Object3D, OrthographicCamera, PerspectiveCamera, Vector3 } from 'three';
import { AnyOptions, ICamera, IEventDispatcher, IOrthographicCameraOptions, IPerspectiveCameraOptions, IUiConfigContainer, UiObjectConfig } from 'webgi/interfaces';
import { SimpleEventDispatcher } from 'webgi/helpers/EventDispatcher';
export declare type TOrbitControlsEvents = 'change' | 'end' | 'start';
export declare type TControlsCtor = (camera: Camera, domElement: HTMLElement | Document) => TCameraControls;
export interface ICameraControls<TEvents = 'change'> extends IUiConfigContainer<void, 'panel'>, IEventDispatcher<TEvents> {
    object: Object3D;
    enabled: boolean;
    dispose(): void;
    update(): void;
    target?: Vector3;
    autoRotate?: boolean;
}
export declare type TCameraControls = ICameraControls<'change' | string>;
export declare class CameraController extends SimpleEventDispatcher<'update'> implements ICamera<IPerspectiveCameraOptions | IOrthographicCameraOptions, PerspectiveCamera | OrthographicCamera, TCameraControls> {
    get controls(): TCameraControls | undefined;
    getControls<T extends TCameraControls>(): T | undefined;
    private _controls?;
    private _controlsMode;
    private _container;
    private _isActiveCamera;
    userData: any;
    get isActiveCamera(): boolean;
    get target(): Vector3;
    set target(target: Vector3);
    get position(): Vector3;
    set position(position: Vector3);
    get name(): string;
    set name(name: string);
    getCameraOptions(): IPerspectiveCameraOptions | IOrthographicCameraOptions;
    setCameraOptions<T extends Partial<IPerspectiveCameraOptions | IOrthographicCameraOptions>>(value: T, setDirty?: boolean): void;
    private _refreshCameraOptions;
    private _camera;
    private _cameraObjectUpdate;
    private _setCameraObject;
    get interactionsEnabled(): boolean;
    set interactionsEnabled(value: boolean);
    private _interactionsEnabled;
    autoLookAtTarget: boolean;
    /**
     * Near clipping plane. This is managed by RootScene for active cameras
     */
    near: number;
    /**
     * Far clipping plane. This is managed by RootScene for active cameras
     */
    far: number;
    protected _nearFarChanged(): void;
    private _options;
    private _position;
    private _target;
    constructor(camera?: OrthographicCamera | PerspectiveCamera, options?: Partial<IPerspectiveCameraOptions | IOrthographicCameraOptions>, domElement?: HTMLElement);
    refreshAspect(setDirty?: boolean): void;
    refreshTarget(): void;
    private _controlsCtors;
    setControlsCtor(key: string, ctor: TControlsCtor, replace?: boolean): void;
    removeControlsCtor(key: string): void;
    private _initCameraControls;
    private _disposeCameraControls;
    refreshCameraControls(setDirty?: boolean): void;
    setDirty(options?: AnyOptions): void;
    activateMain(refresh?: boolean): void;
    deactivateMain(refresh?: boolean): void;
    get cameraObject(): PerspectiveCamera | OrthographicCamera;
    get modelObject(): PerspectiveCamera | OrthographicCamera;
    private _camUi;
    uiConfig: UiObjectConfig;
    assetType: 'model';
    dispose(): void;
    targetUpdated(setDirty?: boolean): void;
    positionUpdated(setDirty?: boolean): void;
    positionTargetUpdated(setDirty?: boolean): void;
    copyFromCamera(camera: PerspectiveCamera | OrthographicCamera, distanceFromTarget?: number): void;
    updateShaderProperties(material: {
        defines: Record<string, string | number | undefined>;
        uniforms: {
            [p: string]: IUniform;
        };
    }): this;
    toJSON(meta?: any): any;
    fromJSON(data: any, meta?: any): this | null;
    refreshCameraOptions(setDirty?: boolean): void;
    readonly uuid: string;
    get visible(): boolean;
    set visible(value: boolean);
}
//# sourceMappingURL=CameraController.d.ts.map