import { IUniform, Vector2, WebGLRenderer, WebGLRenderTargetOptions } from 'three';
import { Class, CreateRenderTargetOptions, ICamera, ICameraOptions, IFilter, IModel, IPass, IPassID, IRenderer, IRenderOptions, IRenderTarget, IScene, ITexture } from 'webgi/interfaces';
import { SimpleEventDispatcher } from '../../helpers/EventDispatcher';
import { EffectComposer2 } from './EffectComposer2';
export declare class BaseRenderer extends SimpleEventDispatcher<'animationLoop' | 'update' | 'resize'> implements IRenderer {
    get composer(): EffectComposer2;
    get passes(): IFilter<IPass, IPassID>[];
    get isWebGL2(): boolean;
    get composerTarget(): IRenderTarget;
    private _isWebGL2;
    private _composerTarget;
    get renderSize(): Vector2;
    private _trackedTargets;
    get displayCanvasScaling(): number;
    set displayCanvasScaling(value: number);
    dirty: boolean;
    get frameCount(): number;
    set pipeline(value: IPassID[]);
    get pipeline(): IPassID[];
    refreshPipeline(): IPassID[];
    get context(): WebGLRenderingContext;
    get rendererObject(): WebGLRenderer;
    private _renderer;
    private _lastTime;
    frameWaitTime: number;
    private _animationLoop;
    private _composer;
    private _context;
    private _passes;
    private _pipeline;
    private _passesNeedsUpdate;
    get clock(): import("three").Clock;
    registerPass(pass: IFilter<IPass, IPassID>, replaceId?: boolean): void;
    unregisterPass(pass: IFilter<IPass, IPassID>): void;
    constructor({ animationLoop, canvas, alpha, targetOptions, }: {
        animationLoop?: (ev: any) => void;
        antialias?: boolean;
        alpha?: boolean;
        canvas: HTMLCanvasElement;
        targetOptions: CreateRenderTargetOptions;
    });
    private _displayCanvasScaling;
    private _renderSize;
    setSize(width?: number, height?: number, force?: boolean): void;
    blit(source: ITexture | undefined, destination: IRenderTarget | undefined, { viewport, material, shader, pass, clear }?: IRenderOptions): void;
    clearColor({ r, g, b, a, target, depth, stencil }: {
        r?: number;
        g?: number;
        b?: number;
        a?: number;
        target?: IRenderTarget;
        depth?: boolean;
        stencil?: boolean;
    }): void;
    renderModel(model: IModel, camera: ICamera<ICameraOptions>): void;
    renderScene(scene: IScene): void;
    private _frameCount;
    private _updated;
    render(): void;
    updateDirty(): void;
    reset(): void;
    resetShadows(): void;
    refreshPasses(): void;
    dispose(): void;
    trackTarget(target: IRenderTarget): void;
    removeTrackedTarget(target: IRenderTarget): void;
    createTarget({ sizeMultiplier, samples, encoding, type, format, depthBuffer, depthTexture, size, textureCount, ...op }?: CreateRenderTargetOptions, trackTarget?: boolean): IRenderTarget;
    private _processNewTarget;
    disposeTarget(target: IRenderTarget): void;
    createTargetCustom<T extends IRenderTarget>({ width, height, count }: {
        width: number;
        height: number;
        count?: number;
    }, options?: WebGLRenderTargetOptions, clazz?: Class<T>): T;
    private _tempTargets;
    getTempTarget(op?: CreateRenderTargetOptions): IRenderTarget;
    private _processNewTempTarget;
    readonly maxTempPerKey = 5;
    releaseTempTarget(target: IRenderTarget): void;
    updateShaderProperties(material: {
        defines: Record<string, string | number | undefined>;
        uniforms: {
            [name: string]: IUniform;
        };
    }): this;
    private _setTargetOptions;
}
export declare function createRenderTargetKey(op?: CreateRenderTargetOptions): string;
//# sourceMappingURL=BaseRenderer.d.ts.map