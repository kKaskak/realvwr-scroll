import { Box3Helper, Color, Group, IUniform, Object3D, Scene, Texture, Vector4 } from 'three';
import { AddModelOptions, AnyOptions, IEvent, ILight, IModel, IScene, ISceneObject, ITexture, IWidget, TSceneEvents } from 'webgi/interfaces';
import { CameraController } from './CameraController';
import { Box3B } from 'webgi/helpers/threejs/Box3B';
export interface AddObjectOptions {
    addToRoot?: boolean;
}
export declare class RootScene<TCamera extends CameraController = CameraController> extends Scene implements IScene<Scene, TCamera> {
    isRootScene: boolean;
    assetType: 'model';
    private _sceneBounds;
    private _sceneBoundingRadius;
    /**
     * For visualizing the scene bounds. API incomplete.
     * @type {Box3Helper}
     */
    readonly boxHelper: Box3Helper;
    private _cameras;
    private _activeCamera;
    /**
     * The root object where all imported objects are added.
     * @type {IModel<Group> & Group}
     */
    readonly modelRoot: IModel<Group> & Group;
    /**
     * The default camera in the scene
     * @type {CameraController}
     */
    readonly defaultCamera: TCamera;
    /**
     * The intensity for the environment light.
     */
    envMapIntensity: number;
    /**
     * Updates the intensity of all objects in the scene. This is automatically called when {@link envMapIntensity} is changed.
     * @param root - Optional root object to traverse.
     * @returns {this<TCamera>}
     */
    refreshEnvMapIntensity(root?: Object3D): this;
    private _dummyCam;
    /**
     * The current active camera in the scene.
     * @returns {TCamera}
     */
    get activeCamera(): TCamera;
    set activeCamera(camera: TCamera | undefined);
    /**
     * Get the threejs scene object
     * @returns {Scene}
     */
    get modelObject(): Scene;
    /**
     * Create a scene instance. This is done automatically in the {@link ViewerApp} and must not be created separately.
     * @param camera
     */
    constructor(camera: TCamera);
    /**
     * Add a processed model to the scene.
     * @param model
     * @param options
     * @returns {IModel<Object3D>}
     */
    addModel(model: IModel<Object3D>, options?: AddModelOptions): IModel;
    /**
     * Add a widget (non-physical/interactive) object to the scene. like gizmos, ui components etc.
     * @param model
     * @param options
     */
    addWidget(model: IWidget, options?: AnyOptions): void;
    protected _addModel(model: IModel, options?: AddObjectOptions & AddModelOptions): void;
    /**
     * Add any processed scene object to the scene.
     * @param imported
     * @param options
     * @returns {T}
     */
    addSceneObject<T extends ISceneObject = ISceneObject>(imported: T, options?: AddObjectOptions & AddModelOptions): T;
    private _addObject3D;
    removeSceneModels(): void;
    disposeSceneModels(): void;
    /**
     * @deprecated Use setEnvironment
     */
    environment: Texture | null;
    private _onEnvironmentChange;
    /**
     * @deprecated Use setBackground
     */
    background: null | Color | Texture;
    /**
     * @deprecated Use addSceneObject
     */
    add(...object: Object3D[]): this;
    /**
     * Set the scene environment map, this will be processed with PMREM automatically later.
     * @param asset
     * @returns {void}
     */
    setEnvironment(asset: ITexture | null | undefined): void;
    /**
     * Get the current scene environment map
     * @returns {ITexture<Texture>}
     */
    getEnvironment(): ITexture<Texture>;
    /**
     * @warn Use {@see ViewerApp.setBackground}
     */
    setBackground(asset: ITexture | string | number | Color | Vector4 | null): void;
    /**
     * @warn Use {@see ViewerApp.getBackground}
     */
    getBackground(): ITexture | Color | Vector4 | null;
    /**
     * Mark the scene dirty, and force render in the next frame.
     * @param options - set sceneUpdate to true to to mark that any object transformations have changed. It might trigger effects like frame fade depening on plugins.
     * @returns {this}
     */
    setDirty(options?: {
        sceneUpdate?: boolean;
    } & AnyOptions): this;
    /**
     * Equivalent to setDirty({sceneUpdate: true}), dispatches 'sceneUpdate' event with the specified options.
     * @param options
     */
    updateScene(options?: AnyOptions): this;
    private _activeCameraUpdate;
    private _onSceneUpdate;
    private _onSceneMaterialUpdate;
    /**
     * Dispose the scene and clear all resources.
     * @warn Not implemented yet.
     */
    dispose(): void;
    /**
     * Find objects by name exact match in the complete hierarchy.
     * @param name - name
     * @param parent - optional root node to start search from
     * @returns Array of found objects
     */
    findObjectsByName(name: string, parent?: Object3D): (Object3D & IModel<Object3D>[])[];
    /**
     * Add a processed light to the scene.
     * @param light
     * @param options
     */
    addLight(light: ILight, options?: AddObjectOptions): void;
    private _addLight;
    /**
     * Returns the bounding box of the scene model root.
     * @param precise
     * @param ignoreInvisible
     * @returns {Box3B}
     */
    getBounds(precise?: boolean, ignoreInvisible?: boolean): Box3B;
    /**
     * Refreshes the scene active camera near far values, based on the scene bounding box.
     * This is called automatically every time the camera is updated.
     */
    refreshActiveCameraNearFar(): void;
    /**
     * Minimum Camera near plane
     */
    minNearDistance: number;
    updateShaderProperties(material: {
        defines: Record<string, string | number | undefined>;
        uniforms: {
            [name: string]: IUniform;
        };
    }): this;
    /**
     * Serialize the scene properties
     * @param meta
     * @returns {any}
     */
    toJSON(meta?: any): any;
    /**
     * Deserialize the scene properties
     * @param json - object from {@link toJSON}
     * @param meta
     * @returns {this<TCamera>}
     */
    fromJSON(json: any, meta?: any): this;
    addEventListener<T extends TSceneEvents>(type: T, listener: (e: IEvent<T>) => void): void;
    removeEventListener<T extends TSceneEvents>(type: T, listener: (e: IEvent<T>) => void): void;
}
//# sourceMappingURL=RootScene.d.ts.map